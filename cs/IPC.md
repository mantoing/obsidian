---
날짜: '"2024-04-28"'
넘버: 
태그: CS
출처: 
aliases:
---
### 날짜  2024-04-28 04:51

### 태그:

>[!메모]
>

### 원문

### IPC

- 프로세스는 독립적으로 실행된다. 즉, 독립 되어있다는 것은 다른 프로세스에게 영향을 받지 않는다고 말할 수 있다.
- 이런 독립적 구조를 가진 **프로세스 간의 통신** 을 해야 하는 상황이 있을 것이다. 이를 가능하도록 해주는 것이 바로 **IPC 통신** 이다.

![[Pasted image 20240428045622.png]]

자세히 설명하자면

1. 위 그림처럼 우리가 사용하는 프로세스들은 모두 유저공간에서 개별로 OS로부터 할당 받은 독립된 공간에서 운행중에 있다.
2. 프로세스는 독립된 공간에서 운행하다보니 서로간에 통신이 어렵다는 문제가 있다.
3. 이를 해결하고자 커널 영역 에서 IPC라는 프로세스들 간에 통신을 제공하고 있다.
4. 이처럼 프로세스들은 커널이 제공하는 IPC기술을 통해 프로세스간에 통신을 할 수 있다.

### IPC의 종류
---
---

#### 파이프
---


> 두 개의 프로세스 간에 단 방향으로 데이터를 전송하는 매커니즘

![[Pasted image 20240428051256.png]]

**특징**

- ***단방향 통신*** : 파이프는 단방향으로만 데이터를 전송할 수 있다. 이것은 보통 한 프로세스가 파이프를 통해 데이터를 쓰고, 다른 프로세스가 그 데이터를 읽는 방식이다.
- ***운영 체제 수준의 매커니즘***: 파이프는 운영 체제 수준에서 구현되며, 프로세스 간 통신을 위해 커널 내부에 데이터 스크림을 생성한다.
- ***파일 디스크립터를 통한 접근***: 파이프는 파일 디스크립터를 사용하여 접근된다. 파일 디스크립터는 읽기 또는 쓰기 파이프를 가리키며, 이를 통해 파이프에 데이터를 쓰거나 읽을 수 있다.
- ***부모-자식 프로세스 간 통신***: 부모 프로세스가 생성한 파이프는 해당 부모 프로세스와 자식 프로세스 간에 통신할 수 있는 효과적인 수단이다.

**장점**

- ***간단한 구현*** : 파이프는 구현이 간단하며, 운영 체제가 제공하는 표준 함수를 사용하여 쉽게 사용할 수 있다.
- ***운영 체제 제원*** : 대부분의 UNIX 및 UNIX 계열 운영 체제에서 파이프를 지원하므로 이식성이 좋다.
- ***표준 입력/출력 과의 호환*** : 파이프는 표준 입력 및 표준 출력과 호환되므로, 기존의 표준 입출력 방식을 쉽게 대체할 수 있다.

**단점**

- ***단방향 통신*** : 파이프는 단방향으로만 데이터를 전송할 수 있기 떄문에 양방향 통신이 필요한 경우 다른 IPC 매커니즘을 사용해야 한다.
- ***크기 제한*** : 파이프의 크기에는 제한이 있으므로 대량의 데이터를 처리해야 하는 경우 문제가 발생할 수  있다.


**예제**

```c
#include <stdio.h>
#include <unistd.h>
#include <string.h>

#define BUFFER_SIZE 100

int main() {
    int pipe_fds[2];
    pid_t pid;
    char message[BUFFER_SIZE];

    // 파이프 생성
    if (pipe(pipe_fds) == -1) {
        perror("파이프 생성 실패");
        return 1;
    }

    // 자식 프로세스 생성
    pid = fork();

    if (pid == -1) {
        perror("프로세스 생성 실패");
        return 1;
    } else if (pid == 0) { // 자식 프로세스
        close(pipe_fds[1]); // 쓰기 파이프 닫기
        read(pipe_fds[0], message, BUFFER_SIZE); // 파이프로부터 메시지 읽기
        printf("자식 프로세스가 받은 메시지: %s\n", message);
        close(pipe_fds[0]); // 읽기 파이프 닫기
    } else { // 부모 프로세스
        close(pipe_fds[0]); // 읽기 파이프 닫기
        char *message = "안녕하세요, 자식 프로세스!";
        write(pipe_fds[1], message, strlen(message) + 1); // 파이프에 메시지 쓰기
        close(pipe_fds[1]); // 쓰기 파이프 닫기
    }

    return 0;
}

```




#### Named PIPE(FIFO)
---

> 파이프와 같은 개념이지만 비휘발성, 파일형태

**특징**

- ***파일 시스템에 존재*** : named 파이프는 파일 시스템에 특별한 파일로 존재한다. 이 파일은 다른 일반 파일과 마찬가지로 파일 경로를 통해 접근할 수 있다.
- ***FIFO(First-In-First-Out)*** : named 파이프는 FIFO의 원칙을 따른다. 즉, 데이터가 먼저 도착한 순서대로 처리된다.
- ***프로세스 간 통신*** : named 파이프는 두 개 이상의  프로세스 간에 통신을 할 수 있는 효과적인 수단이다. 데이터를 파이프에 쓰는 프로세스는 다른 프로세스에서 데이터를 읽을 수 있다.

**장점**

- ***파일 시스템에 존재*** : 파일 시스템에 존재하기 때문에 파일 경로를 통해 여러 프로세스가 접근할 수 있다. 이는 다른 IPC 매커니즘에 비해 더 많은 유연성을 제공한다.
- ***프로세스 간 통신*** : 두 개 이상의 프로세스 간에 데이터를 주고받을 수 있는 강력한 매커니즘 이다. 이를 통해 다른 프로세스 간의 상호작용이 가능해 진다.

**단점**

- ***디스크 공간 사용*** : 명명된 파이프는 파일 시스템에 저장되므로 디스크 공간을 사용한다. 이는 메모리 기반의 IPC 매커니즘에 비해 성능에 영향을 줄 수 있다.
- ***파일 시스템 리소스 제한*** : 파일 시스템은 일반적으로 제한된 리소스를 가지고 있으므로 많은 명명된 파이프를 생성하는 경우 시스템 리소스가 고갈 될 수 있다.

**예제**
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>

#define BUFFER_SIZE 100

int main() {
    char *fifo_path = "/tmp/my_fifo"; // named 파이프의 경로
    char message[BUFFER_SIZE];
    int fifo_fd;

    // 명명된 파이프 생성
    mkfifo(fifo_path, 0666);

    // 파이프 열기 (읽기 및 쓰기 모드)
    fifo_fd = open(fifo_path, O_RDWR);

    // 메시지 쓰기
    write(fifo_fd, "Hello, FIFO!", sizeof("Hello, FIFO!"));

    // 파이프로부터 메시지 읽기
    read(fifo_fd, message, BUFFER_SIZE);
    printf("Received message: %s\n", message);

    // 파이프 닫기
    close(fifo_fd);

    // 명명된 파이프 제거
    unlink(fifo_path);

    return 0;
}

```


그렇다면 **pipe**와 **Named PIPE(FIFO)** 의 차이점은 ?

#### pipe와 Named PIPE(FIFO)의 차이
---
1. **파일 시스템 내 존재 여부**
	- ***Named Pipe*** : 파일 시스템에 특정한 파일로 존재한다. 파일 경로를 통해 접근할 수 있으며, 파일 시스템 내에 존재하기 때문에 다양한 프로세스 간 통신에 유연성을 제공한다.
	- ***Pipe*** : 파일 시스템에 존재하지 않고, 메모리 내에만 존재한다. 따라서 파일 시스템 경로를 통해 직접 접근할 수 없으며, 부모 프로세스와 자식 프로세스 간의 통신에 주로 사용된다.

2. **지속성**
	- ***Named Pipe*** : 파일 시스템에 존재하므로 파이프 생성한 후에도 지속된다. 다시 말해, 파이프를 생성한 프로세스가 종료되더라도 파일 시스템에 남아 있다.
	- ***Pipe*** : 부모 프로세스와 자식 프로세스 간의 통신에만 사용되며, 부모 프로세스나 자식 프로세스가 종료되면 파이프도 함께 소멸된다.
	
3. **접근방법**
	- ***Named Pipe*** : 파일 시스템 경로를 통해 명명된 파이프에 접근한다. 따라서 다른 프로세스도 파일 시스템 경로를 알고 있다면 해당 파이프에 접근할 수 있다.
	- ***Pipe*** : 부모 프로세스와 자식 프로세스 간의 통신에 사용되며 , fork()함수를 통해 생성된 자식 프로세스는 부모 프로세스로부터 상속받은 파일 디스크립터를 사용하여 파이프에 접근한다.
4. **복잡성**
	- ***Named Pipe*** : 파일 시스템에 존재하기 때문에 파일의 생성, 삭제 및 관ㄹ리 등 추가적인 작업이 필요하다. 따라서 Named Pipe를 사용하는 것이 파이프보다 더 복잡할 수 있다.
	- ***Pipe*** : 메모리 내에만 존재하기 때문에 추가적인 파일 시스템 작업이 필요하지 않다. 따라서 구현이 간단하고 사용하기 쉽다.

즉, Named Pipe(FIFO)는 파일 시스템에 존재하여 지속되며, 파일 경로를 통해 접근할 수 있다. 이는 다른 프로세스도 해당 파일 경로를 알고 있다면 명명된 파이프에 접근할 수 있어 유연성을 제공한다. 반면에 파이프는 메모리 내에만 존재하며 부모 프로세스와 자식 프로세스 간의 통신에 사용된다. 이들 간의 통신은 부모 프로세스로부터 상속받은 파일 디스크립터를 통해 이루어지며, 부모나 자식 프로세스가 종료되면 파이프도 함께 소멸된다.

#### Message Queue
---
![[스크린샷 2024-04-28 오후 7.23.29.png]]

> 공유 메모리가 데이터 자체를 공유하도록 지원하는 설비

**개념과 특징**

 발신자와 수신자 간의 통신을 위해 사용된다. 발신자는 메세지를 큐에 추가하고, 수신자는 큐에서 메시지를 꺼내서 처리한다. 이러한 방식으로 데이터를 안전하게 전달하고 처리할 수 있다.

- ***비동기 통신*** : 메시지 큐는 비동기적으로 작동하여 발신자와 수신자 간에 독립적인 통신을 가능하게 한다.
- ***큐 구조*** : 메시지는 큐에 추가되고, 이후에 수신자가 이를 꺼내어 처리한다.FIFO(First-In-First-Out) 방식을 따른다.
- ***신뢰성*** : 메시지 큐는 메시지 전달을 보장하므로 데이터 손실이나 메시지 유실의 위험이 없다.
- ***다양한 데이터 타입*** : 메시지 큐는 다양한 데이터 타입을 지원하므로 텍스트, 바이너리 데이터 등을 전송할 수 있다.

**장점**

- ***비동기 통신*** : 비동기 통신으로 시스템의 효율성을 향상시킨다.
- ***신뢰성*** : 메시지 전달을 보장하여 안정적인 통신을 제공한다.
- ***유연성*** : 다양한 데이터 타입을 지원하고, 메시지 큐의 크기도 동적으로 조정할 수 있다.

**단점**

- ***복잡성*** : 메시지 큐를 사용하는 것은 파이프나 공유 메모리에 비해 구현이 더 복잡할 수 있다.
- ***오버헤드*** : 메시지 큐에는 추가적인 오버헤드가 발생할 수 있으며, 이는 시스템 리소스를 소비할 수 있다.

**예제**

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <mqueue.h>

#define MAX_MSG_SIZE 256
#define QUEUE_NAME "/my_message_queue"

int main() {
    mqd_t mq; // 메시지 큐 디스크립터
    struct mq_attr attr;
    char buffer[MAX_MSG_SIZE + 1];
    int msg_len;

    // 메시지 큐 속성 설정
    attr.mq_flags = 0;
    attr.mq_maxmsg = 10;
    attr.mq_msgsize = MAX_MSG_SIZE;
    attr.mq_curmsgs = 0;

    // 메시지 큐 생성
    mq = mq_open(QUEUE_NAME, O_CREAT | O_RDWR, 0644, &attr);
    if (mq == -1) {
        perror("mq_open");
        exit(1);
    }

    // 메시지 송신
    printf("메시지를 입력하세요: ");
    fgets(buffer, MAX_MSG_SIZE, stdin);
    msg_len = strlen(buffer);
    buffer[msg_len - 1] = '\0'; // 개행 문자 제거

    if (mq_send(mq, buffer, msg_len, 0) == -1) {
        perror("mq_send");
        exit(1);
    }

    printf("메시지 송신 완료\n");

    // 메시지 수신
    memset(buffer, 0, sizeof(buffer)); // 버퍼 초기화

    if (mq_receive(mq, buffer, MAX_MSG_SIZE, NULL) == -1) {
        perror("mq_receive");
        exit(1);
    }

    printf("수신된 메시지: %s\n", buffer);

    // 메시지 큐 닫기 및 제거
    if (mq_close(mq) == -1) {
        perror("mq_close");
        exit(1);
    }

    if (mq_unlink(QUEUE_NAME) == -1) {
        perror("mq_unlink");
        exit(1);
    }

    return 0;
}

```

#### Semaphore
---
> 프로세스 간 데이터를 동기화하고 보호하는데 그 목적이 있다.

**특징**

 정수형 변수로, 공유 자원의 접근을 제어하기 위해 사용된다.
 값이 양수인 경우에는 자원에 대한 접근을 허용하고, 값이 음수인 경우에는 자원에 대한 접근을 차단한다.
 1. ***동기화***: 세마포어를 사용하여 프로세스나 스레드 간의 동기화를 가능하게 한다.
 2. ***상호배제*** : 세마포어를 사용하여 공유 자원에 대한 상호 배제를 구현할 수 있다.
 3. ***차단*** : 세마포어 값이 0 이하인 경우, 대기 상태로 전환하여 프로세스나 스레드를 차단시킨다.

**장점**

- ***유연성*** : 세마포어는 다양한 상황에서 사용할 수 있으며, 동기화 문제를 해결하는 데 유용하다.
- ***확장성*** : 세마포어를 조합하여 복잡한 동기화 문제를 해결할 수 있다.
- ***효율성*** : 세마포어는 간단한 연산으로 구현되어 있어서 상대적으로 효율적이다.

**단점**

- ***DeadLock*** : 잘못된 사용으로 인해 데드락이 발생할 수 있다. 즉, 프로세스나 스레드 간의 상호배제로 인해 상태가 무한히 대기하는 상황이 발생할 수 있다.
- ***변수 공유 문제*** : 세마포어를 사용하여 변수를 공유하는 경우, 경쟁 조건이 발생할 수 있다. 즉, 변수의 일관성이 깨질 수 있다.

#### 뮤텍스와 세마포어의 차이 ? 

**뮤텍스**

> 상호 배제를 위한 동기화 기법으로, 한 번에 하나의 스레드만이 공유자원에 접근할 수 있도록 보장한다. 이진 상태를 가지며, 잠금과 해제연산을 통해 공유 자원의 안전한 접근을 보장한다. 주로 다중 스레드 환경에서 공유 자원에 대한 안전한 접근을 위해 사용된다.

**뮤텍스와 세마포어의 차이**

| 특성      | 뮤텍스                       | 세마포어                         |
| ------- | ------------------------- | ---------------------------- |
| 타입      | 이진 세마포어(Binary Semaphore) | 카운팅 세마포어(Counting Semaphore) |
| 값       | 0 또는 1                    | 0 이상의 정수                     |
| 사용 용도   | 상호배제(Mutual Exclusion)    | 상호배제 및 동기화(Synchronization)  |
| 대기 큐 관리 | FIFO(First-In-First-Out)  | FIFO 또는 우선순위 기반              |
| 잠금 해제   | Lock() 및 Unlock() 함수 사용   | P() 및 V() 함수 사용              |
| 리소스 공유  | 단일 리소스에 사용                | 여러 리소스에 사용 가능                |
| 초기값     | 잠금(1)                     | 사용 가능한 리소스 수                 |
| 사용 예시   | 스레드 간의 상호배제               | 프로세스 간의 동기화, 자원 관리           |
| 구현      | 주로 플랫폼 또는 라이브러리 제공        | 주로 운영 체제에 의해 제공              |

#### Shared Memory(공유 메모리)

![[스크린샷 2024-04-28 오전 7.40.15.png]]

> 두 개 이상의 프로세스가 같은 메모리 영역을 공유하여 데이터를 주고 받는다.

**특징** 

하나의 프로세스가 생성한 메모리 영역을 다른 프로세스가 접근하여 데이터를 공유하는 기법이다. 메모리 영역은 특정 파일 시스템에 존재하지 않고, 각 프로세스의 주소 공간에 매핑되어 있다.

- ***효율성*** : 데이터를 복사하지 않고 메모리를 공유하기 때문에 데이터 교환에 효율적이다.
- ***빠른 속도*** : 메모리에 직접 접근하기 때문에 다른 IPC 메커니즘보다 빠른 속도를 제공한다.
- ***간편한 구현*** : 시스템 호출을 통해 간단하게 공유 메모리를 설정하고 사용할 수 있다.

**장점** 

- ***높은 성능*** : 메모리를 직접 공유하기 떄문에 다른 IPC 매커니즘에 비해 높은 성능을 제공한다.
- ***간편한 통신*** : 별도의 데이터 복사 과정 없이 메모리를 공유하기 때문에 통신이 간편하다.

**단점**

- ***동기화 문제*** : 여러 프로세스가 동시에 메모리를 수정할 수 있으므로 공기화 문제가 발생할 수 있다.
- ***보안 문제*** : 메모리를 공유하기 때문에 보안이 취약할 수 있으며, 신뢰할 수 없는 프로세스로부터 공격을 받을 수 있다.

효율적인 데이터 교환을 위해 주로 사용되지만, 동기화와 보안 문제에 대한 고려가 필요하다.

**예제** 

```c
#include <sys/ipc.h>

#include <sys/shm.h>

#include <unistd.h>

#include <stdlib.h>

#include <stdio.h>

#include <string.h>

#include <errno.h>

  

int main(int ac, char **av) {

int shmid;

int *num;

key_t key;

void *shmp = NULL;

key = 0x20211013;

shmid = shmget(key, 0, 0666 | IPC_EXCL);

if (shmid == -1) {

Logout(INFOR , "%06x shared memory 없음", key);

if ((shmid=shmget(key,sizeof(int), IPC_CREAT|0666)) == -1) {

Logout(ERROR, "shmget failed:%s\n", strerror(errno));

exit(0);

}

}

if((shmp = shmat(shmid, NULL, 0)) == (void *)-1) {

Logout(ERROR, "shmat failed: %s\n", strerror(errno));

exit(0);

}

num=(int *)shmp;

(*num)++;

Logout(INFOR, "shared memory value : %d\n", (*num));

  

shmdt(shmp);

}
```


#### Memory Map (메모리 맵)
---

> 파일이나 장치를 메모리 주소 공간에 매핑하는 것을 의미 한다.


**특징**

파일이나 장치와 메모리 간의 매핑을 제공하는 기술, 파일이나 장치를 메모리에 직접 매핑하여 접근할 수 있도록 한다.

1. ***파일 접근*** : 파일을 메모리에 매핑하여 파일을 읽고 쓸 수 있다.
2. ***장치 접근*** : 장치를 메모리에 매핑하여 디바이스 드라이버와 직접 통신할 수 있다.
3. ***간편한 접근*** : 매핑된 메모리는 포인터를 통해 일반 메모리처럼 접근할 수 있어 편리하다.

**장점** 

- ***빠른 접근*** : 메모리 매핑을 통해 파일이나 장치에 직접 접근하여 데이터를 읽고 쓸 수 있어 빠른 속도를 제공한다.
- ***간편한 인터페이스*** : 포인터를 통해 메모리에 접근하기 때문에 별도의 파일 또는 장치 입출력 함수가 필요하지 않다.

**단점**

- ***제한된 용량*** : 시스템의 가용한 메모리 용량에 제한이 있으므로 매핑할 수 있는 파일 크기가 제한될 수 있다.
- ***보안 문제*** : 메모리 매핑을 통해 파일에 대한 직접 접근이 가능하기 때문에 보안에 취약할 수 있다.

**예제**

```c
#include <stdio.h>

#include <stdlib.h>

#include <sys/stat.h>

#include <fcntl.h>

#include <sys/types.h>

#include <sys/mman.h>

#define MAP_NAME "./MAP_FILE"

typedef struct _ORD{

int type;

double prc;

double qty;

}ORD;

  

int main(int ac, char **av) {

int fd;

ORD *pord;

void *map;

size_t size;

fd = open(MAP_NAME, O_RDWR | O_CREAT, 0666);

size = sizeof(ORD) * 1000 -1;

lseek(fd, size, SEEK_SET);

write(fd, "", 1);

close(fd);

  

fd = open(MAP_NAME, O_RDWR);

map = mmap(NULL, size, PROT_WRITE | PROT_READ, MAP_SHARED, fd, 0);

close(fd);

  

munmap(map, size);

}
```

```c
#include <stdio.h>

#include <stdlib.h>

#include <sys/stat.h>

#include <fcntl.h>

#include <sys/types.h>

#include <sys/mman.h>

#define MAP_NAME "./MAP_FILE"

typedef struct _ORD{

int type;

double prc;

double qty;

}ORD;

  

int main(int ac, char **av) {

int fd;

ORD *pord;

void *map;

size_t size;

fd = open(MAP_NAME, O_RDWR);

map = mmap(NULL, size, PROT_WRITE | PROT_READ, MAP_SHARED, fd, 0);

close(fd);

  

munmap(map, size);

}
```


---
### 생각(파생된 질문/생각)

### 출처

### 연결 문서 (연결 이유)