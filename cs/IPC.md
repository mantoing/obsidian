---
날짜: '"2024-04-28"'
넘버: 
태그: CS
출처: 
aliases:
---
### 날짜  2024-04-28 04:51

### 태그:

>[!메모]
>

### 원문

### IPC

- 프로세스는 독립적으로 실행된다. 즉, 독립 되어있다는 것은 다른 프로세스에게 영향을 받지 않는다고 말할 수 있다.
- 이런 독립적 구조를 가진 **프로세스 간의 통신** 을 해야 하는 상황이 있을 것이다. 이를 가능하도록 해주는 것이 바로 **IPC 통신** 이다.

![[Pasted image 20240428045622.png]]

자세히 설명하자면

1. 위 그림처럼 우리가 사용하는 프로세스들은 모두 유저공간에서 개별로 OS로부터 할당 받은 독립된 공간에서 운행중에 있다.
2. 프로세스는 독립된 공간에서 운행하다보니 서로간에 통신이 어렵다는 문제가 있다.
3. 이를 해결하고자 커널 영역 에서 IPC라는 프로세스들 간에 통신을 제공하고 있다.
4. 이처럼 프로세스들은 커널이 제공하는 IPC기술을 통해 프로세스간에 통신을 할 수 있다.

### IPC의 종류
---
---

#### 파이프
---


> 두 개의 프로세스 간에 단 방향으로 데이터를 전송하는 매커니즘

![[Pasted image 20240428051256.png]]

**특징**

- ***단방향 통신*** : 파이프는 단방향으로만 데이터를 전송할 수 있다. 이것은 보통 한 프로세스가 파이프를 통해 데이터를 쓰고, 다른 프로세스가 그 데이터를 읽는 방식이다.
- ***운영 체제 수준의 매커니즘***: 파이프는 운영 체제 수준에서 구현되며, 프로세스 간 통신을 위해 커널 내부에 데이터 스크림을 생성한다.
- ***파일 디스크립터를 통한 접근***: 파이프는 파일 디스크립터를 사용하여 접근된다. 파일 디스크립터는 읽기 또는 쓰기 파이프를 가리키며, 이를 통해 파이프에 데이터를 쓰거나 읽을 수 있다.
- ***부모-자식 프로세스 간 통신***: 부모 프로세스가 생성한 파이프는 해당 부모 프로세스와 자식 프로세스 간에 통신할 수 있는 효과적인 수단이다.

**장점**

- ***간단한 구현*** : 파이프는 구현이 간단하며, 운영 체제가 제공하는 표준 함수를 사용하여 쉽게 사용할 수 있다.
- ***운영 체제 제원*** : 대부분의 UNIX 및 UNIX 계열 운영 체제에서 파이프를 지원하므로 이식성이 좋다.
- ***표준 입력/출력 과의 호환*** : 파이프는 표준 입력 및 표준 출력과 호환되므로, 기존의 표준 입출력 방식을 쉽게 대체할 수 있다.

**단점**

- ***단방향 통신*** : 파이프는 단방향으로만 데이터를 전송할 수 있기 떄문에 양방향 통신이 필요한 경우 다른 IPC 매커니즘을 사용해야 한다.
- ***크기 제한*** : 파이프의 크기에는 제한이 있으므로 대량의 데이터를 처리해야 하는 경우 문제가 발생할 수  있다.


**예제**

```c
#include <stdio.h>
#include <unistd.h>
#include <string.h>

#define BUFFER_SIZE 100

int main() {
    int pipe_fds[2];
    pid_t pid;
    char message[BUFFER_SIZE];

    // 파이프 생성
    if (pipe(pipe_fds) == -1) {
        perror("파이프 생성 실패");
        return 1;
    }

    // 자식 프로세스 생성
    pid = fork();

    if (pid == -1) {
        perror("프로세스 생성 실패");
        return 1;
    } else if (pid == 0) { // 자식 프로세스
        close(pipe_fds[1]); // 쓰기 파이프 닫기
        read(pipe_fds[0], message, BUFFER_SIZE); // 파이프로부터 메시지 읽기
        printf("자식 프로세스가 받은 메시지: %s\n", message);
        close(pipe_fds[0]); // 읽기 파이프 닫기
    } else { // 부모 프로세스
        close(pipe_fds[0]); // 읽기 파이프 닫기
        char *message = "안녕하세요, 자식 프로세스!";
        write(pipe_fds[1], message, strlen(message) + 1); // 파이프에 메시지 쓰기
        close(pipe_fds[1]); // 쓰기 파이프 닫기
    }

    return 0;
}

```




#### Named PIPE(FIFO)
---

> 파이프와 같은 개념이지만 비휘발성, 파일형태

**특징**

- ***파일 시스템에 존재*** : named 파이프는 파일 시스템에 특별한 파일로 존재한다. 이 파일은 다른 일반 파일과 마찬가지로 파일 경로를 통해 접근할 수 있다.
- ***FIFO(First-In-First-Out)*** : named 파이프는 FIFO의 원칙을 따른다. 즉, 데이터가 먼저 도착한 순서대로 처리된다.
- ***프로세스 간 통신*** : named 파이프는 두 개 이상의  프로세스 간에 통신을 할 수 있는 효과적인 수단이다. 데이터를 파이프에 쓰는 프로세스는 다른 프로세스에서 데이터를 읽을 수 있다.

**장점**

- ***파일 시스템에 존재*** : 파일 시스템에 존재하기 때문에 파일 경로를 통해 여러 프로세스가 접근할 수 있다. 이는 다른 IPC 매커니즘에 비해 더 많은 유연성을 제공한다.
- ***프로세스 간 통신*** : 두 개 이상의 프로세스 간에 데이터를 주고받을 수 있는 강력한 매커니즘 이다. 이를 통해 다른 프로세스 간의 상호작용이 가능해 진다.

**단점**

- ***디스크 공간 사용*** : 명명된 파이프는 파일 시스템에 저장되므로 디스크 공간을 사용한다. 이는 메모리 기반의 IPC 매커니즘에 비해 성능에 영향을 줄 수 있다.
- ***파일 시스템 리소스 제한*** : 파일 시스템은 일반적으로 제한된 리소스를 가지고 있으므로 많은 명명된 파이프를 생성하는 경우 시스템 리소스가 고갈 될 수 있다.

**예제**
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>

#define BUFFER_SIZE 100

int main() {
    char *fifo_path = "/tmp/my_fifo"; // named 파이프의 경로
    char message[BUFFER_SIZE];
    int fifo_fd;

    // 명명된 파이프 생성
    mkfifo(fifo_path, 0666);

    // 파이프 열기 (읽기 및 쓰기 모드)
    fifo_fd = open(fifo_path, O_RDWR);

    // 메시지 쓰기
    write(fifo_fd, "Hello, FIFO!", sizeof("Hello, FIFO!"));

    // 파이프로부터 메시지 읽기
    read(fifo_fd, message, BUFFER_SIZE);
    printf("Received message: %s\n", message);

    // 파이프 닫기
    close(fifo_fd);

    // 명명된 파이프 제거
    unlink(fifo_path);

    return 0;
}

```


그렇다면 **pipe**와 **Named PIPE(FIFO)** 의 차이점은 ?

#### pipe와 Named PIPE(FIFO)의 차이
---
1. **파일 시스템 내 존재 여부**
	- ***Named Pipe*** : 파일 시스템에 특정한 파일로 존재한다. 파일 경로를 통해 접근할 수 있으며, 파일 시스템 내에 존재하기 때문에 다양한 프로세스 간 통신에 유연성을 제공한다.
	- ***Pipe*** : 파일 시스템에 존재하지 않고, 메모리 내에만 존재한다. 따라서 파일 시스템 경로를 통해 직접 접근할 수 없으며, 부모 프로세스와 자식 프로세스 간의 통신에 주로 사용된다.

2. **지속성**
	- ***Named Pipe*** : 파일 시스템에 존재하므로 파이프 생성한 후에도 지속된다. 다시 말해, 파이프를 생성한 프로세스가 종료되더라도 파일 시스템에 남아 있다.
	- ***Pipe*** : 부모 프로세스와 자식 프로세스 간의 통신에만 사용되며, 부모 프로세스나 자식 프로세스가 종료되면 파이프도 함께 소멸된다.
	
3. **접근방법**
	- ***Named Pipe*** : 파일 시스템 경로를 통해 명명된 파이프에 접근한다. 따라서 다른 프로세스도 파일 시스템 경로를 알고 있다면 해당 파이프에 접근할 수 있다.
	- ***Pipe*** : 부모 프로세스와 자식 프로세스 간의 통신에 사용되며 , fork()함수를 통해 생성된 자식 프로세스는 부모 프로세스로부터 상속받은 파일 디스크립터를 사용하여 파이프에 접근한다.
4. **복잡성**
	- ***Named Pipe*** : 파일 시스템에 존재하기 때문에 파일의 생성, 삭제 및 관ㄹ리 등 추가적인 작업이 필요하다. 따라서 Named Pipe를 사용하는 것이 파이프보다 더 복잡할 수 있다.
	- ***Pipe*** : 메모리 내에만 존재하기 때문에 추가적인 파일 시스템 작업이 필요하지 않다. 따라서 구현이 간단하고 사용하기 쉽다.

즉, Named Pipe(FIFO)는 파일 시스템에 존재하여 지속되며, 파일 경로를 통해 접근할 수 있다. 이는 다른 프로세스도 해당 파일 경로를 알고 있다면 명명된 파이프에 접근할 수 있어 유연성을 제공한다. 반면에 파이프는 메모리 내에만 존재하며 부모 프로세스와 자식 프로세스 간의 통신에 사용된다. 이들 간의 통신은 부모 프로세스로부터 상속받은 파일 디스크립터를 통해 이루어지며, 부모나 자식 프로세스가 종료되면 파이프도 함께 소멸된다.

#### Message Queue
---

![[스크린샷 2024-04-28 오전 7.40.15.png]]

> 공유 메모리가 데이터 자체를 공유하도록 지원하는 설비

**개념과 특징**

 발신자와 수신자 간의 통신을 위해 사용된다. 발신자는 메세지를 큐에 추가하고, 수신자는 큐에서 메시지를 꺼내서 처리한다. 이러한 방식으로 데이터를 안전하게 전달하고 처리할 수 있다.

- ***비동기 통신*** : 메시지 큐는 비동기적으로 작동하여 발신자와 수신자 간에 독립적인 통신을 가능하게 한다.
- ***큐 구조*** : 메시지는 큐에 추가되고, 이후에 수신자가 이를 꺼내어 처리한다.FIFO(First-In-First-Out) 방식을 따른다.
- ***신뢰성*** : 메시지 큐는 메시지 전달을 보장하므로 데이터 손실이나 메시지 유실의 위험이 없다.
- ***다양한 데이터 타입*** : 메시지 큐는 다양한 데이터 타입을 지원하므로 텍스트, 바이너리 데이터 등을 전송할 수 있다.

**장점**

- ***비동기 통신*** : 비동기 통신으로 시스템의 효율성을 향상시킨다.
- ***신뢰성*** : 메시지 전달을 보장하여 안정적인 통신을 제공한다.
- ***유연성*** : 다양한 데이터 타입을 지원하고, 메시지 큐의 크기도 동적으로 조정할 수 있다.

**단점**

- ***복잡성*** : 메시지 큐를 사용하는 것은 파이프나 공유 메모리에 비해 구현이 더 복잡할 수 있다.
- ***오버헤드*** : 메시지 큐에는 추가적인 오버헤드가 발생할 수 있으며, 이는 시스템 리소스를 소비할 수 있다.

**예제**

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <mqueue.h>

#define MAX_MSG_SIZE 256
#define QUEUE_NAME "/my_message_queue"

int main() {
    mqd_t mq; // 메시지 큐 디스크립터
    struct mq_attr attr;
    char buffer[MAX_MSG_SIZE + 1];
    int msg_len;

    // 메시지 큐 속성 설정
    attr.mq_flags = 0;
    attr.mq_maxmsg = 10;
    attr.mq_msgsize = MAX_MSG_SIZE;
    attr.mq_curmsgs = 0;

    // 메시지 큐 생성
    mq = mq_open(QUEUE_NAME, O_CREAT | O_RDWR, 0644, &attr);
    if (mq == -1) {
        perror("mq_open");
        exit(1);
    }

    // 메시지 송신
    printf("메시지를 입력하세요: ");
    fgets(buffer, MAX_MSG_SIZE, stdin);
    msg_len = strlen(buffer);
    buffer[msg_len - 1] = '\0'; // 개행 문자 제거

    if (mq_send(mq, buffer, msg_len, 0) == -1) {
        perror("mq_send");
        exit(1);
    }

    printf("메시지 송신 완료\n");

    // 메시지 수신
    memset(buffer, 0, sizeof(buffer)); // 버퍼 초기화

    if (mq_receive(mq, buffer, MAX_MSG_SIZE, NULL) == -1) {
        perror("mq_receive");
        exit(1);
    }

    printf("수신된 메시지: %s\n", buffer);

    // 메시지 큐 닫기 및 제거
    if (mq_close(mq) == -1) {
        perror("mq_close");
        exit(1);
    }

    if (mq_unlink(QUEUE_NAME) == -1) {
        perror("mq_unlink");
        exit(1);
    }

    return 0;
}

```

#### Semaphore
---
> 프로세스 간 데이터를 동기화하고 보호하는데 그 목적이 있다.




---
### 생각(파생된 질문/생각)

### 출처

### 연결 문서 (연결 이유)