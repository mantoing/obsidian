---
날짜: '"2024-01-25"'
넘버: 
태그: 
출처: recoil공식문서
aliases:
---
### 날짜  2024-01-25 14:50

### 태그:

>[!메모]
>

### 원문
---

# Recoil 시작하기
> Recoil은 Reacr를 위한 상태관리 라이브러리 이기때문에 react환경에서 사용해야한다.


## Recoil의 시작

호환성 및 단순함을 이유로 외부의 글로벌 상태관리 라이브러리보다는 React자체에 내장된 상태관리 기능을 사용하는 것이 가장 좋다. 
But! 리액트의 한계때문에 개선을 하고자 만들기 시작함

- 리액트의 한계
	- 컴포넌트 상태는 공통된 상위요소까지 끌어올려야만 공유될 수 있으며, 이 과정에서 거대한 트리가 다시 렌더링 되는 효과를 야기하기도 한다.
	- Context는 단일 값만 저장할 수 있으며, Consumer를 가지는 여러값의 집합을 담을 수는 없다.
	- 이 두가지 특성이 트리의 최상단(state의 root) 부터 트리의 말단(state가 실질적으로 사용되는 곳) 까지의 코드분할을 어렵게 만든다.


따라서 recoil이 개발되었다.
recoil은 orthogonal(독립적인 특성을 가짐)하지만, 본질적인 방향 그래프를 정의하고 React트리에 붙인다. 상태변화는 이 그래프의 뿌리(Atoms)부터 순수함수 (selector)를 거쳐 컴포넌트로 흐른다.
> 이게 무슨말..?
> 일단 "직교"란 각각의 상태나 로직이 독립적으로 존재하며, 서로에게 영향을 미치지 않는다는 의미.
> 그럼 본질적인 방향그래프는 먼데... 그 뜻은 데이터의 흐름이 일정한 방향을 가지는 그래프를 의미한다.

그렇다면 Atoms와 selector은 뭘까?
- Atoms(원자): Recoil에서 상태의 기본단위로, 애플리케이션 전역에서 사용되는 상태를 정의한다. 이러한 상태들은 직교하게 존재하며, 각각 독립적으로 업데이트될 수 있다.
	더 자세한건 [[2. Atoms]]글에서 따로 설명하겠다.
- Selector(셀렉터): Atoms에서 파생된 값 또는 변환된 값들을 나타내는데 사용된다. 이는 순수함수로 정의되며 다양한 Atoms의 상태를 결합하거나 가공하여 새로운 값을 생성한다.
	 더 자세한건 [[3. Selector]]글에서 따로 설명하겠다.

간단히 말해서 Recoil은 Atoms와 Selector을 사용하여 상태가 변화가 한 곳에서 시작해서 순수함수를 통해 처리되고, 최종적으로 컴포넌트로 전달된다는 것이다. 이를 통해 상태의 효과적인 관리와 업데이트를 할 수 있다.

### 접근방식

- 우리는 공유상태(shared state)도 React의 내부상태(local state)처럼 간단한 get/set 인터페이스로 사용할 수 있도록 boilerplate-free API를 제공한다. (필요한 경우 reducers 등으로 캡슐화할 수도 있다)
- 우리는 동시성 모드(Concurrent Mode)를 비롯한 다른 새로운 React의 기능들과의 호환 가능성도 갖는다.
- 상태 정의는 점진적이고(incremental) 분산되어 있기 때문에, 코드 분할이 가능하다.
- 상태를 사용하는 컴포넌트를 수정하지 않고도 상태를 파생된 데이터로 대체할 수 있다.
- 파생된 데이터를 사용하는 컴포넌트를 수정하지 않고도 파생된 데이터는 동기식과 비동기식 간에 이동할 수 있다.
- 우리는 탐색을 일급 개념으로 취급할 수 있고 심지어 링크에서 상태 전환을 인코딩할 수도 있다.
- 전체 애플리케이션 상태를 하위 호환되는 방식으로 유지하기가 쉬우므로, 유지된 상태는 애플리케이션 변경에도 살아남을 수 있다.

쉽게 요약하자면 
1. **간편한 API:** React 내장 상태 관리를 보완하는데, 간단한 get/set 인터페이스를 통해 공유 상태를 다룸.
    
2. **React 기능 호환:** 동시성 모드와 같은 최신 React 기능과 호환되어 사용 가능.
    
3. **분산된 상태 정의:** 상태를 점진적이고 분산된 방식으로 정의하여 코드 분할을 용이하게 함.
    
4. **컴포넌트 수정 없는 상태 교체:** 상태를 사용하는 컴포넌트 수정 없이도 파생된 데이터로 교체 가능.
    
5. **동기/비동기 상태 전환:** 파생된 데이터를 사용하는 컴포넌트 수정 없이 동기/비동기식 상태 전환 가능.
    
6. **일급 탐색 개념:** 탐색을 일급 개념으로 취급하며 링크에서 상태 전환을 인코딩 가능.
    
7. **하위 호환성 유지:** 전체 애플리케이션 상태를 쉽게 유지하면서 변경 가능.

---
### 생각(파생된 질문/생각)

### 출처

### 연결 문서 (연결 이유)